
#version 430  // Version of OpenGL with COMPUTE shader support

layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in; // Declares thread group size

const int blurFactor = 20;

//spatial kernel (same as blur earlier in the semester)
uniform blurKernel {float weights[blurFactor * 2 + 1]; }; // Declares a uniform block

//uses shadowTexture[0] as input and its in format RGBA32F
layout (rgba16f) uniform readonly image2D depthMap;

//uses GBufferTexture[1] as input and its in format RGBA16F
layout (rgba16f) uniform readonly image2D normalMap;

//uses SSAOBlurTexture[0] as output and its in format R32F
layout (r32f) uniform writeonly image2D dst;

const float PI = 3.1415926535897932384626433832795;

shared float sharedDepthVar[128 + (blurFactor * 2) + 1]; // Variable shared with other threads in the 128x1 thread group2
shared vec4 sharedNormalVar[128 + (blurFactor * 2) + 1]; // Variable shared with other threads in the 128x1 thread group2

float SSAOScalar = 0.01f;


void main()
{

  ivec2 gpos = ivec2(gl_GlobalInvocationID.xy); // Combo of groupID, groupSize and localID
  uint invocID = gl_LocalInvocationID.x; // Local thread id in the 128x1 thread groups128x1

  sharedDepthVar[invocID] = imageLoad(depthMap, gpos + ivec2(- blurFactor, 0)).a; // read an image pixel at an ivec2(.,.) position
  sharedNormalVar[invocID] = imageLoad(normalMap, gpos + ivec2(- blurFactor, 0));

  if (invocID < 2.0f * blurFactor)
  {
    sharedDepthVar[invocID + 128] = imageLoad(depthMap, gpos + ivec2(128 - blurFactor,0)).a; // read extra 2*w pixels
    sharedNormalVar[invocID + 128] = imageLoad(normalMap, gpos + ivec2(128 - blurFactor,0));
  }

  barrier(); // Wait for all threads to catchup before reading sharedVar[]
  
  //float B = 1/(blurFactor * 2 + 1);
  //float s = blurFactor / 2;
  float w = 0;
  //for i in rance -w to w so 2w + 1
  //Compute sum of weights[0 … 2w] times corresponding pixels v[i … i+2w]
  //W(xi,x) = R(xi,x) * S(xi, x)
  //S = weights from gaussian vlur
  //R = range kernel

  vec3 normal = sharedNormalVar[invocID].xyz;  //N
  float depth = sharedDepthVar[invocID];    //d

  for(uint i = invocID; i < invocID + (blurFactor * 2); ++i)
  {
    
    vec3 normal_i = sharedNormalVar[i].xyz; //Ni
    float depth_i = sharedDepthVar[i];      //di

    float exponent = - ((depth_i - depth) * (depth_i - depth)) / (2.0f * SSAOScalar);
    float R = max(dot(normal,normal_i),0) * (1.0f / (sqrt(2.0f * PI * SSAOScalar))) * exp(exponent);
    
    w += R * weights[i - invocID];
    
  }
  //blurValue.x = 1.0f;
  
  imageStore(dst, gpos, vec4(w,0,0,0)); // Write to destination image
  //imageStore(dst, gpos, vec4(normal,0)); // Write to destination image

}
